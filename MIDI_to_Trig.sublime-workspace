{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"me",
				"menuCourant"
			],
			[
				"menu",
				"menuAffiche"
			],
			[
				"enf",
				"enfantsTrouves"
			],
			[
				"men",
				"menuTeste"
			],
			[
				"pos",
				"possedeDesEnfants"
			],
			[
				"id",
				"id_parent"
			],
			[
				"bou",
				"boutonEnCours"
			],
			[
				"do",
				"dowihle	Arduino do-while"
			],
			[
				"tra",
				"traitementBouton"
			],
			[
				"nombre",
				"nombreItems"
			],
			[
				"etat",
				"etat_bouton"
			],
			[
				"int",
				"int	Arduino int()"
			],
			[
				"aff",
				"affichage"
			],
			[
				"comp",
				"compteur"
			],
			[
				"cara",
				"caractereActuel"
			],
			[
				"tab",
				"tableauDigits"
			],
			[
				"car",
				"caractereTableau"
			],
			[
				"digi",
				"digits"
			],
			[
				"pin",
				"pin_digitActif"
			],
			[
				"donnes",
				"donneesAffichage"
			],
			[
				"donnees",
				"donneesAffichage"
			],
			[
				"pin_",
				"pin_digitInactif"
			],
			[
				"a",
				"affichage_digit"
			],
			[
				"affichage_dig",
				"affichage_digit"
			],
			[
				"di",
				"digitalRead	Arduino digitalRead"
			],
			[
				"digital",
				"digitalWrite	Arduino digitalWrite"
			],
			[
				"Do",
				"donneesAffichage"
			],
			[
				"entre",
				"entreesBoutons"
			],
			[
				"dernier",
				"dernierBoutonPresse"
			],
			[
				"cons",
				"const"
			],
			[
				"ser",
				"Serial"
			],
			[
				"lea",
				"learnFlag"
			],
			[
				"prin",
				"println"
			],
			[
				"com",
				"compteur"
			],
			[
				"A",
				"Auto"
			],
			[
				"compteur",
				"compteurNotesLearn"
			],
			[
				"lear",
				"Learn"
			],
			[
				"Not",
				"NotesLearn"
			],
			[
				"Canal",
				"CanalLearn"
			],
			[
				"N",
				"NotesLearn"
			],
			[
				"Mo",
				"ModeSortie"
			],
			[
				"P",
				"ParamSortie"
			],
			[
				"par",
				"parametres"
			],
			[
				"div",
				"div_clock"
			],
			[
				"comt",
				"compteurClock"
			],
			[
				"bit",
				"bitSet"
			],
			[
				"mill",
				"millis	Arduino millis()"
			],
			[
				"millis",
				"millis	Arduino millis()"
			],
			[
				"tri",
				"Triggers"
			],
			[
				"compte",
				"compteur"
			],
			[
				"seri",
				"seriOut"
			],
			[
				"affi",
				"AFFICHAGE"
			],
			[
				"Af",
				"AFFICHAGE"
			]
		]
	},
	"buffers":
	[
		{
			"contents": "/*\nMIDI to Trig\nLaurent Calvignac\nJanvier 2014\n \n * Ce programme est un programme libre ;\n * vous pouvez le redistribuer et/ou le modifier\n * dans les termes de la licence GNU GPL, comme publiée par\n * la Free Software Foundation; soit dans la version 3 de la license, ou\n * (suivant votre préférence) dans une version ultérieure.\n \n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU GPL as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n \n*/\n \n/*\n \n  sorties 1 a 12 : triggers/gates\n  sortie 13 : accent (velocite > )\n  sortie 14 : play/stop\n  sortie 15 : clock divisee\n  sortie 16 : clock 1:1\n \n*/\n \n#include <string.h>\n#include <MIDI.h>\n#include <SoftwareSerial.h>\n    SoftwareSerial midiSerial(2,3);\n    MIDI_CREATE_INSTANCE(SoftwareSerial, midiSerial, midiBench);\n\n\n\n\n\n/*****************************************************************************\n        VARIABLES\n*****************************************************************************/\n\n//PINS========================================================================\n\n  //Pins connectes aux pins ST_CP des 74HC595\n  const int sorties_latchPin = 3;\n  const int affichage_latchPin = A1;\n\n  //Pins connectes aux pins SH_CP des 74HC595\n  const int sorties_clockPin = 4;\n  const int affichage_clockPin = A2;\n\n  //Pins connectes aux pins DS des 74HC595\n  const int sorties_dataPin = 5;\n  const int affichage_dataPin = A0;\n\n  //Pins utilises pour le multiplexage des afficheurs\n  const int affichage_digit[2] = {A5, A4};\n\n  //Boutons 8=echap 9=gauche 10=droite 11=entree\n  const int entreesBoutons[4] = {8, 9, 10, 11};\n\n//ENUMS=======================================================================\n\n  enum Modes {Trigger, Gate};\n  enum LearnModes {Off, Learn, Auto};\n  enum Ports {Triggers, Affichage};\n  enum Boutons {Echap, Gauche, Droite, Entree};\n\n//PARAMETRES==================================================================\n\n  typedef struct{\n\n      //apprentissage des notes\n      LearnModes NotesLearn;\n\n      //apprentissage du canal midi\n      boolean CanalLearn;\n\n      //canal midi selectionne\n      int Canal;\n\n      //1->12:triggers, 13:Accent, 14:Play/Stop, 15:Clk div, 16: Clk\n      //mode gate ou trigger pour chaque sortie\n      Modes ModeSortie[16];\n\n      //duree du trigger pour chaque sortie\n      int DureeSortie[16];\n\n      //Triggers (1->12) : note autorisee\n      //Accent : velocite seuil\n      //Play/Stop : NC \n      //Div : facteur de division \n      //Clk : NC\n      int ParamSortie[16];\n\n  }structParametres;\n\n  structParametres parametres;\n\n//VARIABLES TEMPORELLES=======================================================\n\n  //Taux de rafraichissement de l'affichage (en ms)\n  byte refreshAffichage = 10;\n\n  //Temps pour le debounging des boutons (en ms)\n  byte tempsDebounce = 20;\n\n  //Utilise pour la division de l'horloge midi\n  byte compteurClock = 0;\n\n  //Utilise pour le rafraichissement des sorties\n  unsigned long millisTriggers[16];\n\n  //Utilise pour le rafraichissement de l'affichage\n  unsigned long millisAffichage;\n\n  //Utilise pour le debouncing des boutons\n  unsigned long millisBoutons[4];\n\n//MENUS=======================================================================\n  typedef struct{\n    char nom[3];\n    int id_parent;\n    int valeur;\n  }menuItem;\n\n  //Nombre d'items dans le menu\n  const byte nombreItems = 6;\n\n  menuItem menu[nombreItems];\n\n  //Le menu dans lequel on est actuellement\n  int menuCourant = -1;\n\n  //Le menu actuellement affiche sur l'ecran\n  int menuAffiche = 0;\n\n//AFFICHAGE===================================================================\n  typedef struct{\n    byte segments;\n    char symbole;\n  }digits;\n\n  //Le tableau contenant les caracteres pour l'afficheur 7 segments\n  digits tableauDigits[40];\n  \n  //donnees a afficher sur les digits\n  char donneesAffichage[2];\n\n//SORTIES=====================================================================\n  \n  //Definit l'etat des sorties trigger/gate\n  word etat_sorties = 0;\n\n  //Associe les sorties (n-1) aux evenements midi\n  byte note[12] = {4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15};\n  byte accent = 0;\n  byte transport = 1;\n  byte div_clock = 2;\n  byte sync_clock = 3;\n\n//BOUTONS=====================================================================\n  \n  byte\n    etat_bouton[4], //\n    dernier_etat_bouton[4], //\n    nouvel_appui[4];  //\n\n//DIVERS======================================================================\n  //Utilise pour savoir si on a fini l'apprentissage (0) ou non (1)\n  boolean learnFlag = 1;\n  //Sert a compter le nombre de notes deja apprises\n  byte compteurNotesLearn = 0;\n  //\n\n  byte i = 0;\n\n/*****************************************************************************\n        FONCTIONS\n*****************************************************************************/\n  //MIDI======================================================================\n    void handleNoteOn(byte inChannel, byte inNote, byte inVelocity) {\n\n      //Si l'on doit apprendre le canal ou les notes\n      if(learnFlag && (parametres.NotesLearn || parametres.CanalLearn)) {\n        //Si l'on doit apprendre le canal\n        if(parametres.CanalLearn) {\n          //On enregistre le canal dans les parametres\n          parametres.Canal = inChannel;\n          //TODO : Il ne faut ecouter que ce canal\n          //Si l'on n'a pas active l'apprentissage des notes\n          if(!parametres.NotesLearn) {\n            //On a fini l'apprentissage\n            learnFlag = 0;\n          }\n        }\n        \n        //Si l'apprentissage des notes est en mode auto\n        if(parametres.NotesLearn == Auto) {\n          //On enregistre cette note et les notes consecutives dans les parametres\n          for(byte compteur = 0; compteur < 12; compteur++) {\n            parametres.ParamSortie[note[compteur]] = inNote + compteur;\n          }\n          //On a fini l'apprentissage\n          learnFlag = 0;\n        }\n        //Sinon, l'apprentissage des notes est en mode learn, on doit les apprendre toutes une par une\n        else if(parametres.NotesLearn == Learn) {\n          //Serial.println(\"Mode Learn\");\n          //On enregistre les notes dans les parametres une par une, dans l'ordre de reception\n          parametres.ParamSortie[note[compteurNotesLearn]] = inNote;\n          //on incremente le compteur\n          compteurNotesLearn++;\n          //Si le compteur arrive a 12, c'est qu'on a assigne une note a chaque sortie\n          if(compteurNotesLearn == 12) {\n            //On a fini l'apprentissage\n            learnFlag = 0;\n          }\n        }\n      }\n\n      for(byte compteur=0; compteur < 12; compteur++) {\n        //Si c'est une des 12 notes assignees a une sortie\n        if(parametres.ParamSortie[note[compteur]] == inNote) {\n          //On active cette sortie\n          bitSet(etat_sorties, note[compteur]);\n          //Si cette sortie est en mode trigger\n          if(parametres.ModeSortie[note[compteur]] == Trigger) {\n            //On demarre le chrono du temps d'impulsion\n            millisTriggers[note[compteur]] = millis();\n          }\n        }\n      }\n\n      if(inVelocity >= parametres.ParamSortie[accent]) {\n        bitSet(etat_sorties, accent);\n        millisTriggers[accent] = millis();\n      }\n\n      //On met a jour l'etat des sorties\n      seriOut(Triggers, etat_sorties);\n\n    }\n\n    void handleNoteOff(byte inChannel, byte inNote, byte inVelocity) {\n\n      for(byte compteur=0; compteur < 12; compteur++) {\n        //Si c'est une des 12 notes assignees a une sortie et que cette sortie est en mode gate\n        if(parametres.ParamSortie[note[compteur]] == inNote && parametres.ModeSortie[note[compteur]] == Gate) {\n          //On desactive cette sortie\n          bitClear(etat_sorties, note[compteur]);\n          //Si cette sortie est en mode trigger\n        }\n      }\n      //On met a jour l'etat des sorties\n      seriOut(Triggers, etat_sorties);\n\n    }\n\n    void handleClock() {\n      //TODO : verifier la precision de cette horloge !\n      //on active la sortie sync24\n      bitSet(etat_sorties, sync_clock);\n      //on demarre le chrono du temps d'impulsion\n      millisTriggers[sync_clock] = millis();\n      //si le compteur de clock est revenu a zero\n      if(compteurClock == 0){\n        //on active la sortie d'horloge divisee\n        bitSet(etat_sorties, div_clock);\n        //on demarre le chrono du temps d'impulsion\n        millisTriggers[div_clock] = millis();\n        //on remet le compteur au facteur de division choisit\n        compteurClock = parametres.ParamSortie[div_clock];\n      }\n      //sinon on decremente le commpteur\n      compteurClock--;\n      seriOut(Triggers, etat_sorties);\n    }\n\n    void handleStart() {\n      //on inverse l'etat de cette sortie\n      bitWrite(etat_sorties, transport, !bitRead(etat_sorties, transport));\n      //si c'est un message start\n      if(midiBench.getType() == midi::Start){\n        //on remet a zero le compteur de clock\n        compteurClock = 0;\n      }\n      //si on est en mode trig\n      if(parametres.ModeSortie[transport] == Trigger){\n        //on demarre le chrono du temps d'impulsion\n        millisTriggers[transport] = millis();\n      }\n      //on met a jour l'etat des sorties\n      seriOut(Triggers, etat_sorties);\n      if(midiBench.getType() == midi::Start){Serial.println(\"Start\");}\n    }\n\n    void handleContinue() {\n      handleStart();\n      Serial.println(\"Continue\");\n    }\n\n    void handleStop() {\n      handleStart();\n      Serial.println(\"Stop\");\n      killNotes();\n    }\n\n    /*void handleControlChange(byte channel, byte number, byte value) {\n      if(number == 114 && value == 127) {handleStop();}\n    }*/\n\n    void killNotes() {\n      for(byte compteur=0; compteur < 12; compteur++) {\n        //On eteint toutes les notes\n        bitClear(etat_sorties, note[compteur]);\n      }\n      //On met a jour l'etat des sorties\n      seriOut(Triggers, etat_sorties);\n    }\n\n  //DELAIS====================================================================\n\n    void verifier_delais() {\n      unsigned long millisActuel = millis();\n      //extinction des sorties\n      for(int compteur=0; compteur<16; compteur++){\n          //si on a depasse le temps et que la sortie est en mode trigger et qu'elle est actuellement active :\n          if((millisActuel - millisTriggers[compteur]) > parametres.DureeSortie[compteur] && parametres.ModeSortie[compteur] == Trigger && bitRead(etat_sorties, compteur) == 1){\n              bitClear(etat_sorties, compteur); //on passe cette sortie en off\n              seriOut(Triggers, etat_sorties); //on envoie cette donnee sur le port serie des sorties\n          }\n      }\n      //rafraichissement de l'affichage\n      if(millisActuel - millisAffichage > refreshAffichage){\n          affichage();\n      }\n    }\n\n  //SORTIE SERIE==============================================================\n    void seriOut(Ports port, byte donnees) {\n      byte dataPin;\n      byte clockPin;\n      byte latchPin;\n      switch (port) {\n          case Triggers:\n            dataPin = sorties_dataPin;\n            clockPin = sorties_clockPin;\n            latchPin = sorties_latchPin;\n            break;\n          case Affichage:\n            dataPin = affichage_dataPin;\n            clockPin = affichage_clockPin;\n            latchPin = affichage_latchPin;\n            break;\n      }\n      digitalWrite(latchPin, LOW);\n      if(port == Triggers){\n        shiftOut(dataPin, clockPin, MSBFIRST, (donnees >> 8));      \n      }\n      shiftOut(dataPin, clockPin, MSBFIRST, donnees);\n      digitalWrite(latchPin, HIGH);\n    }\n\n  //AFFICHAGE=================================================================\n\n    void affichage() {\n      byte pin_digitActif;\n      byte pin_digitInactif;\n      byte donnees;\n    \n      //On active le digit qui n'etait pas actif lors de la lecture precedente\n      boolean lecture = digitalRead(affichage_digit[0]);\n      pin_digitActif = affichage_digit[lecture];\n      pin_digitInactif = affichage_digit[!lecture];\n      donnees = donneesAffichage[lecture];\n   \n      digitalWrite(pin_digitInactif, LOW);  //desactivation du digit precedent\n      seriOut(Affichage, donnees);  //transmission des donnees sur le port AFFICHAGE\n      digitalWrite(pin_digitActif, HIGH); //activation du digit courant\n      millisAffichage = millis();\n    }\n\n  //CREATION DIGITS===========================================================\n \n    void creation_digits(const char* caracteres) {\n      //TODO\n      //ici, rechercher correspondance entre les caracteres en entree et le\n      //tableau des digits pour en deduire le numero du digit a afficher.\n      //Penser a afficher du vide devant lorsqu'il n'y a qu'un seul digit.\n      \n      byte compteur = 0;\n\n      for(int i=0; i < 2; i++){\n        compteur = 0;\n        while(caracteres[i] != tableauDigits[compteur].symbole) {\n          compteur++;\n        }\n        donneesAffichage[i] = tableauDigits[compteur].segments;\n      }    \n    }\n\n  //ENTREE BOUTON=============================================================\n\n    void verifierBoutons() {\n\n      for(byte compteur = 0; compteur < 4; compteur++){\n\n        //on enregistre le temps actuel\n        unsigned long millisActuel = millis();\n        \n        //lire l'entree du bouton-poussoir\n        byte lecture = digitalRead(entreesBoutons[compteur]);\n       \n        //comparer l'etat du bouton a son etat precedent\n        //si le statut du bouton a change\n        if (lecture != dernier_etat_bouton[compteur]) {\n          //on enregistre le temps actuel\n          millisBoutons[compteur] = millisActuel;\n        }\n        \n        //Si on a passe e temps de debouncing\n        if((millisActuel - millisBoutons[compteur]) > tempsDebounce){\n          \n          //si l'etat du bouton a change\n          if(lecture != etat_bouton[compteur]) {\n            etat_bouton[compteur] = lecture;\n       \n            //si le bouton est presse\n            if(etat_bouton[compteur] == true) {\n              traitementBouton((Boutons) compteur);\n              strcpy(donneesAffichage, menu[menuAffiche].nom);\n              creation_digits(donneesAffichage);\n            }    \n          }      \n        }\n        dernier_etat_bouton[compteur] = lecture;\n         \n      }\n    }\n\n  //TRAITEMENT BOUTON=========================================================\n\n    void traitementBouton(Boutons dernierBoutonPresse) {\n\n      switch (dernierBoutonPresse) {\n\n        case Echap:\n          Serial.println(\"Echap\");\n          //Si on n'est pas a la racine\n          if(menuCourant > -1) {\n            menuCourant = menu[menuCourant].id_parent;\n            do {\n              menuAffiche++;\n              if(menuAffiche > nombreItems) {\n                menuAffiche = 0;\n              }\n            } while (menu[menuAffiche].id_parent != menuCourant);\n          }\n          // do something\n          break;\n          \n        case Gauche:\n          Serial.println(\"Gauche\");\n          do {\n            if(menuAffiche == 0) {\n              menuAffiche = nombreItems;\n            }\n            menuAffiche--;\n          } while (menu[menuAffiche].id_parent != menuCourant);\n          break;\n\n        case Droite:\n          Serial.println(\"Droite\");\n          do {\n            menuAffiche++;\n            if(menuAffiche > nombreItems) {\n              menuAffiche = 0;\n            }\n          } while (menu[menuAffiche].id_parent != menuCourant);\n          break;\n\n        case Entree:\n          Serial.println(\"Entree\");\n\n          //Si le menu sur lequel on vient de cliquer possede des enfants\n          if(possedeDesEnfants(menuAffiche)) {\n            menuCourant = menuAffiche;\n            do {\n              menuAffiche++;\n              if(menuAffiche > nombreItems) {\n                menuAffiche = 0;\n              }\n            } while (menu[menuAffiche].id_parent != menuCourant);\n          }\n          // do something\n          break;\n        \n        default:\n          Serial.println(\"Erreur traitementBouton\");\n      }\n\n    }\n\n  //MENUS=====================================================================\n\n    //Verifie si le menu teste possede des enfants\n    boolean possedeDesEnfants(byte menuTeste) {\n      boolean enfantsTrouves = false;\n      for(int i=0; i<nombreItems; i++){\n        if(menu[i].id_parent == menuTeste) {\n          enfantsTrouves = true;\n        }\n      }\n      return enfantsTrouves;\n    }\n\n/*****************************************************************************\n        SETUP\n*****************************************************************************/\n  void setup() {\n\n    //MENU====================================================================\n      \n      //Juste pour faciliter l'ajout de menus\n      byte id = 0;\n\n      //Clock division\n        id = 0;\n        strncpy(menu[id].nom, \"di\", 3);\n        menu[id].id_parent = -1;\n        menu[id].valeur = 24;  //1->96\n      //Root note\n        id = 1;\n        strncpy(menu[id].nom, \"no\", 3);\n        menu[id].id_parent = -1;\n        menu[id].valeur = 0;\n      //Canal\n        id = 2;\n        strncpy(menu[id].nom, \"ch\", 3);\n        menu[id].id_parent = -1;\n        menu[id].valeur = 0; //-1 = learn / 1->16\n      //Start / Stop;\n        id = 3;\n        strncpy(menu[id].nom, \"St\", 3);\n        menu[id].id_parent = -1;\n        menu[id].valeur = 0; //0 = trig / 1 = gate\n      //Start / Stop;\n        id = 4;\n        strncpy(menu[id].nom, \"tr\", 3);\n        menu[id].id_parent = 3;\n        menu[id].valeur = 0; //0 = trig / 1 = gate\n      //Start / Stop;\n        id = 5;\n        strncpy(menu[id].nom, \"gt\", 3);\n        menu[id].id_parent = 3;\n        menu[id].valeur = 0; //0 = trig / 1 = gate\n       \n       \n      /*enum menus {\n      HOME,\n      CLOCK,\n      CLOCK_DIV,\n      NOTE,\n      NOTE_SELEC,\n      CANAL,\n      CANAL_SELEC,\n      START,\n      START_SELEC,\n        SORTIES,\n        SORTIES_MODE,\n        SORTIES_MODE_SELEC,\n        SORTIES_MODE_SELEC_MODE,\n        SORTIES_DUREE,\n        SORTIES_DUREE_SELEC,\n        SORTIES_DUREE_SELEC_DUREE,\n        ACCENT,\n        ACCENT_SELEC,\n        LEARN\n      };*/\n\n    //PINS====================================================================\n\n      pinMode(sorties_latchPin, OUTPUT);\n      pinMode(sorties_clockPin, OUTPUT);\n      pinMode(sorties_dataPin, OUTPUT);\n      \n      pinMode(affichage_latchPin, OUTPUT);\n      pinMode(affichage_clockPin, OUTPUT);\n      pinMode(affichage_dataPin, OUTPUT);\n      pinMode(affichage_digit[0], OUTPUT);\n      pinMode(affichage_digit[1], OUTPUT);\n\n      pinMode(entreesBoutons[0], INPUT);\n      pinMode(entreesBoutons[1], INPUT);\n      pinMode(entreesBoutons[2], INPUT);\n      pinMode(entreesBoutons[3], INPUT);\n\n    //AFFICHAGE===============================================================\n    //                                                             GFABDC.E\n    tableauDigits[0].symbole  = '0'; tableauDigits[0].segments  = B01111101;\n    tableauDigits[1].symbole  = '1'; tableauDigits[1].segments  = B00010100;\n    tableauDigits[2].symbole  = '2'; tableauDigits[2].segments  = B10111001;\n    tableauDigits[3].symbole  = '3'; tableauDigits[3].segments  = B10111100;\n    tableauDigits[4].symbole  = '4'; tableauDigits[4].segments  = B11010100;\n    tableauDigits[5].symbole  = '5'; tableauDigits[5].segments  = B11101100;\n    tableauDigits[6].symbole  = '6'; tableauDigits[6].segments  = B11101101;\n    tableauDigits[7].symbole  = '7'; tableauDigits[7].segments  = B00110100;\n    tableauDigits[8].symbole  = '8'; tableauDigits[8].segments  = B11111101;\n    tableauDigits[9].symbole  = '9'; tableauDigits[9].segments  = B11111100;\n    tableauDigits[10].symbole = 'a'; tableauDigits[10].segments = B10111101;\n    tableauDigits[11].symbole = 'b'; tableauDigits[11].segments = B11001101;\n    tableauDigits[12].symbole = 'c'; tableauDigits[12].segments = B10001001;\n    tableauDigits[13].symbole = 'd'; tableauDigits[13].segments = B10011101;\n    tableauDigits[14].symbole = 'E'; tableauDigits[14].segments = B11101001;\n    tableauDigits[15].symbole = 'F'; tableauDigits[15].segments = B11100001;\n    tableauDigits[16].symbole = 'g'; tableauDigits[16].segments = B11111100;\n    tableauDigits[17].symbole = 'h'; tableauDigits[17].segments = B11000101;\n    tableauDigits[18].symbole = 'i'; tableauDigits[18].segments = B00000001;\n    tableauDigits[19].symbole = 'J'; tableauDigits[19].segments = B00011100;\n    tableauDigits[20].symbole = 'K'; tableauDigits[20].segments = B11010101;\n    tableauDigits[21].symbole = 'L'; tableauDigits[21].segments = B01001001;\n    tableauDigits[22].symbole = 'M'; tableauDigits[22].segments = B01110101;\n    tableauDigits[23].symbole = 'n'; tableauDigits[23].segments = B10000101;\n    tableauDigits[24].symbole = 'o'; tableauDigits[24].segments = B10001101;\n    tableauDigits[25].symbole = 'p'; tableauDigits[25].segments = B11110001;\n    tableauDigits[26].symbole = 'q'; tableauDigits[26].segments = B11110100;\n    tableauDigits[27].symbole = 'r'; tableauDigits[27].segments = B10000001;\n    tableauDigits[28].symbole = 'S'; tableauDigits[28].segments = B11101100;\n    tableauDigits[29].symbole = 't'; tableauDigits[29].segments = B11001001;\n    tableauDigits[30].symbole = 'U'; tableauDigits[30].segments = B01011101;\n    tableauDigits[31].symbole = 'v'; tableauDigits[31].segments = B00001101;\n    tableauDigits[32].symbole = 'W'; tableauDigits[32].segments = B00101101;\n    tableauDigits[33].symbole = 'X'; tableauDigits[33].segments = B11010101;\n    tableauDigits[34].symbole = 'Y'; tableauDigits[34].segments = B11011100;\n    tableauDigits[35].symbole = 'Z'; tableauDigits[35].segments = B10111001;\n    tableauDigits[36].symbole = '.'; tableauDigits[36].segments = B00000010;\n    tableauDigits[37].symbole = '-'; tableauDigits[37].segments = B10000000;\n    //double L\n    tableauDigits[38].symbole = 'l'; tableauDigits[38].segments = B01010101;\n    //vide\n    tableauDigits[39].symbole = '/'; tableauDigits[39].segments = B00000000;\n\n    //CALLBACKS===============================================================\n\n      //Callback Note on\n      midiBench.setHandleNoteOn(handleNoteOn);\n      //Callback Note off \n      midiBench.setHandleNoteOff(handleNoteOff);\n      //Callback Clock\n      midiBench.setHandleClock(handleClock);\n      //Callback Start\n      midiBench.setHandleStart(handleStart);\n      //Callback Stop\n      midiBench.setHandleContinue(handleContinue);\n      //Callback Continue\n      midiBench.setHandleStop(handleStop);\n\n      //Callback CC\n      //midiBench.setHandleControlChange(handleControlChange);\n\n    //PORTS SERIE=============================================================\n\n      //Midi\n      midiBench.begin(MIDI_CHANNEL_OMNI);\n\n      //Serie\n      while(!Serial);\n      Serial.begin(115200);\n      Serial.println(\"Arduino Ready\");\n\n      seriOut(Triggers, 0);\n\n    //DEBUG===================================================================\n      \n      parametres.CanalLearn = 1;\n      parametres.NotesLearn = Learn;\n      \n      parametres.ParamSortie[div_clock] = 24;\n\n      for(int i=0; i<12; i++){\n        parametres.ModeSortie[note[i]] = Gate;\n      }\n      parametres.ModeSortie[transport] = Trigger;\n      \n      for(int i=0; i<16; i++){\n        parametres.DureeSortie[i] = 20;\n      }\n      parametres.DureeSortie[sync_clock] = 0;\n\n      strcpy(donneesAffichage, menu[menuAffiche].nom);\n      creation_digits(donneesAffichage);\n\n  }\n\n/*****************************************************************************\n        MAIN\n*****************************************************************************/\n  void loop() {\n    midiBench.read();\n    //On ne verifie les delais qu'une fois sur 10\n    if(i >= 10) {\n      verifier_delais();\n      verifierBoutons();\n      i = 0;\n    }\n    i++;\n  }\n",
			"file": "MIDI_to_Trig.ino",
			"file_size": 24539,
			"file_write_time": 130426779860031734,
			"settings":
			{
				"buffer_size": 23786,
				"line_ending": "Windows"
			}
		},
		{
			"contents": "Echap\nArduino Ready\nEchap\nArduino Ready\nEchap\nArduino Ready\nEchap\nArduino Ready\nEchap\nArduino Ready\nEchap\nArduino Ready\nEchap\nArduino Ready\nEchap\nArduino Ready\nEchap\nDroite\nDroite\nDroite\nDroite\nDroite\nDroite\nDroite\nEntree\nDroite\nDroite\nDroite\nEchap\nDroite\nDroite\nDroite\nGauche\nGauche\nGauche\n",
			"settings":
			{
				"buffer_size": 326,
				"line_ending": "Windows",
				"name": "Serial Monitor - COM17"
			}
		}
	],
	"build_system": "",
	"command_palette":
	{
		"height": 400.0,
		"selected_items":
		[
			[
				"arduino",
				"Set Syntax: Arduino"
			],
			[
				"insta",
				"Package Control: Install Package"
			],
			[
				"inst",
				"Package Control: Install Package"
			],
			[
				"install",
				"Package Control: Install Package"
			],
			[
				"pack",
				"Package Control: Install Package"
			]
		],
		"width": 408.0
	},
	"console":
	{
		"height": 125.0
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"file_history":
	[
		"/D/Laurent/Mes Documents/GitHub/MIDI-to-trigger/Documents/MIDI_to_Trig_0_7/MIDI_to_Trig_0_7.ino",
		"/C/Users/Laurent.WENG/AppData/Roaming/Sublime Text 2/Packages/User/Preferences.sublime-settings",
		"/D/Laurent/Mes Documents/GitHub/MIDI-to-trigger/MIDI_to_Trig.sublime-project",
		"/D/Laurent/Mes Documents/GitHub/MIDI-to-trigger/MIDI_to_Trig.ino",
		"/C/Users/Laurent.WENG/AppData/Local/Temp/Temp1_Arduino_MIDI_Library_v4.0.zip/MIDI/midi_Defs.h",
		"/D/Laurent/Mes Documents/Dropbox/Boulot/MIDI to Trig/MIDI_to_Trig_0_7/MIDI_to_Trig_0_7.ino",
		"/D/Laurent/Mes Documents/Dropbox/Boulot/MIDI to Trig/MIDI_to_Trig_b1_0/MIDI_to_Trig_b1_0.ino",
		"/D/Laurent/Mes Documents/Arduino/libraries/MIDI/examples/MIDI_Bench/MIDI_Bench.ino",
		"/D/Laurent/Mes Documents/Travaux/20140201_SiteLingyi/Indexhibit/ndxzstudio/defaults.php",
		"/D/Laurent/Mes Images/50SF/6830449.jpg"
	],
	"find":
	{
		"height": 34.0
	},
	"find_in_files":
	{
		"height": 0.0,
		"where_history":
		[
		]
	},
	"find_state":
	{
		"case_sensitive": false,
		"find_history":
		[
			"i",
			"3",
			"2",
			"0",
			"boutonEnCours",
			"i",
			"boutonEnCours",
			"Bouton",
			"bouton",
			"Bouton",
			"BoutonPresse",
			"compteur",
			"TODO",
			"Stop",
			"Precedent",
			"millisActuel",
			"accent",
			"TimeCodeQuarterFrame",
			"NoteOff",
			"midiBench.",
			"data",
			"Start",
			"midiBench",
			";",
			"inNote",
			"in",
			"inNote",
			"sorties_lat",
			"pin",
			"pin_digit2",
			"pin_digit1",
			"seriOut(0, etat_sorties);//on envoie cette donnee sur le port serie des sorties",
			"          seriOut(0, etat_sorties);//on envoie cette donnee sur le port serie des sorties\n",
			");//",
			"seriOut(0, etat_sorties);",
			"TRIGGERS"
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": false,
		"replace_history":
		[
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"selected": 0,
			"sheets":
			[
				{
					"buffer": 0,
					"file": "MIDI_to_Trig.ino",
					"settings":
					{
						"buffer_size": 23786,
						"regions":
						{
						},
						"selection":
						[
							[
								2794,
								2794
							]
						],
						"settings":
						{
							"rulers":
							[
								78
							],
							"syntax": "Packages/Stino-master/Arduino.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true,
							"word_wrap": true,
							"wrap_width": 80
						},
						"translation.x": 0.0,
						"translation.y": 1935.0,
						"zoom_level": 1.0
					},
					"type": "text"
				}
			]
		},
		{
			"selected": 0,
			"sheets":
			[
				{
					"buffer": 1,
					"settings":
					{
						"buffer_size": 326,
						"regions":
						{
						},
						"selection":
						[
							[
								153,
								153
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 0.0
	},
	"input":
	{
		"height": 31.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			],
			[
				1,
				0,
				2,
				1
			]
		],
		"cols":
		[
			0.0,
			0.5,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"output.MIDI-to-trigger":
	{
		"height": 100.0
	},
	"output.MIDI_to_Trig_0_1":
	{
		"height": 100.0
	},
	"output.MIDI_to_Trig_0_2_ino":
	{
		"height": 100.0
	},
	"output.MIDI_to_Trig_0_7":
	{
		"height": 100.0
	},
	"output.MIDI_to_Trig_b1_0":
	{
		"height": 100.0
	},
	"output.stino_log":
	{
		"height": 100.0
	},
	"replace":
	{
		"height": 0.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 0.0,
		"selected_items":
		[
		],
		"width": 0.0
	},
	"show_minimap": true,
	"show_open_files": true,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 150.0,
	"status_bar_visible": true
}
